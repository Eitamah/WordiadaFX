package views.javaFX;

import javafx.fxml.FXML;
import javafx.scene.canvas.Canvas;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;

import java.awt.Point;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.concurrent.TimeUnit;

import javax.xml.bind.JAXBException;

import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

import engine.Game;
import engine.Game.eGameState;
import engine.Tile.eTileState;
import gameSettings.Letter;
import gameSettings.Letters;
import gameSettings.Player;
import gameSettings.Player.ePlayerType;
import engine.GameManager;
import engine.GameSettings.eLoadSteps;
import engine.IllegalLettersException;
import engine.Tile;
import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;

import javafx.scene.control.TabPane;
import javafx.scene.control.TableColumn;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Tab;

import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.control.CheckBox;

import javafx.scene.control.TableView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

public class GameController implements Observer {
	@FXML
	private GridPane gridMainGrid;
	@FXML
	private TabPane tabPaneSettingsTab;
	@FXML
	private Tab tabGameSettings;
	@FXML
	private AnchorPane anchorTabAnchor;
	@FXML
	private CheckBox chkboxGoldFishMode;
	@FXML
	private Label labelScore;
	@FXML
	private ComboBox comboSkin;
	@FXML
	private CheckBox chckboxAnimation;
	@FXML
	private Label labelTilesLeft;
	@FXML
	private Tab tabDictionary;
	@FXML
	private TableView tableDictionary;
	@FXML
	private TableView tablePlayers;
	@FXML
	private TableView tableLetters;
	@FXML
	private TableView tableWords;
	@FXML
	private Button btnPrev;
	@FXML
	private Button btnNext;
	@FXML
	private Button btnLoadButton;
	@FXML
	private Button btnStart;
	@FXML
	private Label lblCurrentPlayer;
	@FXML
	private Button btnAddPlayer;
	@FXML
	private Button btnUndo;
	@FXML
	private Button btnFlip;
	@FXML
	private Button btnForfiet;
	@FXML
	private Label labelWord;
	@FXML
	private Button bntRollDice;
	@FXML
	private Button buttonSubmitWord;
	@FXML
	private AnchorPane anchorGame;
	@FXML
	private TableColumn<StringProperty, String> tableDictionaryWordColumn;
	@FXML
	private TableColumn<Letter, String> tableLettersLettersColumn;
	@FXML
	private TableColumn<Letter, Number> tableLettersFreqColumn;
	@FXML
	private TableColumn<Player, String> tablePlayersNameColumn;
	@FXML
	private TableColumn<Player, String> tablePlayersTypeColumn;
	@FXML
	private TableColumn<Player, Number> tablePlayersIDColumn;
	@FXML
	private TableColumn<Player, Number> tablePlayersScoreColumn;
	@FXML
	private TableColumn<WordTableData, String> tableWordsWordColumn;
	@FXML
	private TableColumn<WordTableData, String> tableWordsScoreColumn;
	@FXML
	private Pane paneBoard;
	@FXML
	private Label labelBoardSize;
	@FXML
	private Label labelGameState;
	@FXML
	private Label labelTurns;
	@FXML
	private Label labelDice;
	@FXML
	private Label labelWordCount;
	@FXML
	private ProgressBar barLoad;

	private Stage primaryStage;
	public GameManager gameManager;
	private TileController[][] board;
	private int currentTurn;
	private eHumanSteps currentStep;
	private int diceRoll = -7;
	private Player currentPlayer;
	private ArrayList<Tile> currentWord;
	private int retriesLeft;

	public GameController(Stage primary, GameManager gm) {
		primaryStage = primary;
		gameManager = gm;
	}

	// Event Listener on ComboBox[#comboSkin].onAction
	@FXML
	public void handleSkinChanged(ActionEvent event) {
	}

	// Event Listener on CheckBox[#chckboxAnimation].onAction
	@FXML
	public void handleAnimationCheck(ActionEvent event) {
		// TODO Autogenerated
	}

	// Event Listener on Button[#btnPrev].onAction
	@FXML
	public void handlePrevBtnPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.FINISHED)) {

			if (currentTurn > 0) {
				currentTurn--;
			}
			Game game = gameManager.getCurrentGame().getTurn(currentTurn);
			loadSavedTurn(game);

		} else {
			ShowAlert("Game must be finished");
		}
	}

	// Event Listener on Button[#btnNext].onAction
	@FXML
	public void handleNextBtnPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.FINISHED)) {

			if (currentTurn < gameManager.getCurrentGame().numOfSavedTurns() - 1) {
				currentTurn++;
			}
			Game game = gameManager.getCurrentGame().getTurn(currentTurn);
			loadSavedTurn(game);

		} else {
			ShowAlert("Game must be finished");
		}
	}

	private void loadSavedTurn(Game savedGame) {
		loadPlayersTable(savedGame);
		loadTilesLeftLabel(savedGame);
		setCurrentPlayer(savedGame);
		loadWordsTable(savedGame);
		loadBoard(savedGame);
		labelWord.setText("Word: " + savedGame.getCurrentPlayer().getLastWord());
	}

	// Event Listener on Button[#btnLoadButton].onAction
	@FXML
	public void handleLoadBtnPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() == null)
				|| (gameManager.getCurrentGame().getStatus() != eGameState.RUNNING)) {
			FileChooser fileChooser = new FileChooser();
			fileChooser.setTitle("Open Resource File");
			File file = fileChooser.showOpenDialog(primaryStage);
			GameController temp = this;
			if (file != null) {
				String input = file.getAbsolutePath();
				try {
					Thread thread = new Thread() {
						public void run() {
							try {
								gameManager.initGame();
								gameManager.getCurrentGame().getSettings().addObserver(temp);
								gameManager.loadGame(input);
							} catch (Exception e) {
								Platform.runLater(() -> {
									ShowAlert(e.getMessage());
								});
							}
						}
					};
					thread.start();

					// loadContent(gameManager.getCurrentGame());

				} catch (Exception e) {
					// TODO Auto-generated catch block
					ShowAlert(e.getMessage());
				}
			}
		} else {
			ShowAlert("Can't load during running game");
		}
	}

	private void loadContent(Game game) {
		chkboxGoldFishMode.setSelected(game.getSettings().getDescriptor().getGameType().isGoldFishMode());
		labelGameState.setText("Game state: " + game.getStatus().toString());
		labelScore.setText("Score: " + game.getSettings().getWinnerBy().toString());
		loadPlayersTable(game);
		loadLettersTable(game);
		loadDictionaryTable(game);
		loadTilesLeftLabel(game);
		setCurrentPlayer(game);
		loadWordsTable(game);
		loadBoard(game);

		// Add observers
		if (gameManager.getCurrentGame() != null) {
			gameManager.getCurrentGame().getBoard().addObserver(this);
			gameManager.getCurrentGame().addObserver(this);
		}
	}

	final class WordTableData {
		SimpleStringProperty word;
		SimpleStringProperty score;
		int count;
		SimpleStringProperty finalString;
	}

	private void loadWordsTable(Game game) {
		HashMap<String, WordTableData> words = new HashMap<String, WordTableData>();

		ArrayList<String> temp = (ArrayList<String>) game.getCurrentPlayer().getWordsPlayed().clone();

		for (String word : temp) {
			if (words.containsKey(word)) {
				words.get(word).count++;
				words.get(word).finalString = new SimpleStringProperty(
						Integer.toString(words.get(word).count) + " * " + word);
			} else {
				WordTableData data = new WordTableData();
				data.count = 1;
				data.word = new SimpleStringProperty(word);
				data.score = new SimpleStringProperty(
						Integer.toString(game.getSettings().getDictionary().getWordSegment(word)) + " * "
								+ game.getSettings().getLetterScore(word) + " = " + game.getSettings().getScore(word));

				data.finalString = new SimpleStringProperty(
						Integer.toString(data.count) + " * " + data.word.getValue());

				words.put(word, data);
			}
		}

		ObservableList<WordTableData> list = FXCollections.observableArrayList();
		for (WordTableData word : words.values()) {
			list.add(word);
		}

		tableWords.setItems(list);
		tableWordsScoreColumn.setCellValueFactory(cellData -> (cellData.getValue().score));
		tableWordsWordColumn.setCellValueFactory(cellData -> (cellData.getValue().finalString));

		tableWords.refresh();

		labelWordCount.setText("Total words: " + game.getCurrentPlayer().getWordsPlayed().size());
	}

	private void loadPlayersTable(Game game) {
		ObservableList<Player> playerList;
		playerList = FXCollections.observableArrayList(game.getSettings().getDescriptor().getPlayers().getPlayer());

		tablePlayers.setItems(playerList);
		tablePlayersNameColumn
				.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getName().get(0)));
		tablePlayersIDColumn.setCellValueFactory(cellData -> (new SimpleIntegerProperty(cellData.getValue().getId())));
		tablePlayersTypeColumn
				.setCellValueFactory(cellData -> (new SimpleStringProperty(cellData.getValue().getType().toString())));
		tablePlayersScoreColumn
				.setCellValueFactory(cellData -> (new SimpleIntegerProperty(game.getScore(cellData.getValue()))));
		tablePlayers.refresh();
	}

	private void loadBoard(Game game) {
		paneBoard.getChildren().clear();
		int size = game.getBoard().getSize();
		labelBoardSize.setText("Board size: " + size);
		board = new TileController[size][size];
		double height = paneBoard.getHeight() / size;
		double width = paneBoard.getWidth() / size;
		paneBoard.setVisible(true);
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				TileController tile = new TileController(this, i, j, game.getTile(i, j), height, width);
				tile.setVisible(true);
				board[i][j] = tile;
				paneBoard.getChildren().add(tile);
			}
		}
	}

	private void setCurrentPlayer(Game game) {
		if (game.getStatus() == eGameState.FINISHED) {
			lblCurrentPlayer.setText("Winner: " + game.getWinner().getName());
		} else {
			lblCurrentPlayer.setText("Current player: " + game.getCurrentPlayer().getName().get(0));
		}
	}

	private void loadDictionaryTable(Game game) {
		List<String> temp = game.getSettings().getDictionary().getLeastPopularWords();

		ObservableList<StringProperty> list = FXCollections.observableArrayList();
		for (String string : temp) {
			list.add(new SimpleStringProperty(string));
		}
		tableDictionary.setItems(list);
		tableDictionaryWordColumn.setCellValueFactory(cellData -> (cellData.getValue()));
		tableDictionary.refresh();
	}

	private void loadLettersTable(Game game) {
		List<Letter> letters = game.getSettings().getDescriptor().getStructure().getLetters().getLetter();
		ObservableList<Letter> f = FXCollections.observableArrayList(letters);

		tableLetters.setItems(f);
		tableLettersFreqColumn
				.setCellValueFactory(cellData -> new SimpleDoubleProperty(cellData.getValue().getFrequency()));
		tableLettersLettersColumn.setCellValueFactory(
				cellData -> new SimpleStringProperty(cellData.getValue().getSign().get(0).toString()));
		tableLetters.refresh();
	}

	private void loadTilesLeftLabel(Game game) {
		labelTilesLeft.textProperty().set("Tiles left : " + Integer.toString(game.getBoard().getTilesLeft()));
	}

	// Event Listener on Button[#btnStart].onAction
	@FXML
	public void handleStartBtnPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null) && (gameManager.getCurrentGame().isSettingsValid())) {
			try {
				gameManager.startGame();

				currentTurn = 0;
				// saved game state at beginning
			} catch (IllegalStateException e) {
				ShowAlert(e.getMessage());
			}
		} else {
			ShowAlert("Load valid settings file first");
		}
	}

	// Event Listener on Button[#btnAddPlayer].onAction
	@FXML
	public void handleAddPlayerBtnPressed(ActionEvent event) {
		// TODO Autogenerated
	}

	// Event Listener on Button[#btnUndo].onAction
	@FXML
	public void handleUndoPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.RUNNING)) {
			if (currentStep == eHumanSteps.CHOOSE_LETTERS) {
				if (currentWord.size() > 0) {
					currentWord.get(currentWord.size() - 1).setSelected(false);
					currentWord.remove(currentWord.size() - 1);
					updateWordLabel();
					refreshBoard();
				}
			}
		}
	}

	@FXML
	public void handleSubmitWordPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.RUNNING)) {
			if (currentStep == eHumanSteps.CHOOSE_LETTERS) {
				if (currentWord.size() > 0) {
					String word = "";

					for (Tile tile : currentWord) {
						word = word + tile.getSign();
					}

					if (gameManager.getCurrentGame().getSettings().getDictionary().isValidWord(word)) {
						gameManager.getCurrentGame().endTurn(currentWord);
						refreshBoard();
					} else {
						retriesLeft--;
						
						if (retriesLeft > 0) {
							ShowAlert("Not a word. you have " + retriesLeft + " tries left");
						} else {
							ShowAlert("Not a word. No tries remaining");
							for (Tile tile : currentWord) {
								tile.setSelected(false);
							}
							currentWord.clear();
							gameManager.getCurrentGame().endTurn(currentWord);
							refreshBoard();
							
							
							
							try {
								TimeUnit.MILLISECONDS.sleep(3000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
//								e.printStackTrace();
							}
							
							
							
							
							
						}
					}
				}
			}
		}
	}

	// Event Listener on Button[#btnFlip].onAction
	@FXML
	public void handleFlipPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.RUNNING)) {

			if (currentStep == eHumanSteps.SELECT_TILES) {
				// count selected
				int selected = gameManager.getCurrentGame().getBoard().countSelected();

				if (selected == diceRoll) {
					currentStep = currentStep.next();
					gameManager.getCurrentGame().getBoard().flipAllSelected();
					// Update UI here.
					refreshBoard();

					currentWord = new ArrayList<Tile>();
					retriesLeft = gameManager.getCurrentGame().getSettings().getDescriptor().getStructure().getRetriesNumber();
				} else {
					ShowAlert("Must select " + diceRoll + " tiles that are faced down");
				}
			} else {
				ShowAlert("Must be during running game and human turn, after dice roll");
			}
		}
	}

	// Event Listener on Button[#btnForfiet].onAction
	@FXML
	public void handleForfietPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null) && (gameManager.getCurrentGame().getStatus() == eGameState.RUNNING)
				&& gameManager.getCurrentGame().getCurrentPlayer().getType() == ePlayerType.HUMAN) {
			gameManager.getCurrentGame().Forfiet();
		} else {
			ShowAlert("Must be running game and human player");
		}
	}

	// Event Listener on Button[#bntRollDice].onAction
	@FXML
	public void handleRollPressed(ActionEvent event) {
		if ((gameManager.getCurrentGame() != null)
				&& (gameManager.getCurrentGame().getStatus() == eGameState.RUNNING)) {
			if (currentStep == eHumanSteps.DICE) {
				diceRoll = gameManager.getCurrentGame().getDiceRoll();
				currentStep = currentStep.next();
				labelDice.setText("Dice roll: " + Integer.toString(diceRoll));
			}
		} else {
			ShowAlert("Must be during running game");
		}
	}

	public void ShowAlert(String message) {
		Alert alert = new Alert(AlertType.INFORMATION);
		alert.setTitle("Info");
		alert.setHeaderText(null);
		alert.setContentText(message);
		alert.showAndWait();
	}

	@Override
	public void update(Observable o, Object arg) {
		Platform.runLater(() -> {
			if (o.getClass() == gameManager.getCurrentGame().getClass()) {
				if ((arg != null) && (int) (arg) == 1) {
					loadContent(gameManager.getCurrentGame());
				}

				// Update UI here.

				refreshBoard();
				if (currentPlayer != gameManager.getCurrentGame().getCurrentPlayer()) {
					currentStep = eHumanSteps.DICE;
					currentPlayer = gameManager.getCurrentGame().getCurrentPlayer();
					diceRoll = -7;
				}

				loadTilesLeftLabel(gameManager.getCurrentGame());
				setCurrentPlayer(gameManager.getCurrentGame());
				loadWordsTable(gameManager.getCurrentGame());
				loadPlayersTable(gameManager.getCurrentGame());
				loadLettersTable(gameManager.getCurrentGame());
				labelGameState.setText("Game state: " + gameManager.getCurrentGame().getStatus().toString());
				labelTurns.setText("Turns: " + gameManager.getCurrentGame().numOfSavedTurns());
				currentTurn = gameManager.getCurrentGame().numOfSavedTurns();
			} else if (o.getClass() == gameManager.getCurrentGame().getSettings().getClass()) {

				eLoadSteps step = (eLoadSteps) arg;
				double progress = (double) step.getValue() / (double) eLoadSteps.FINISHED.getValue();
				barLoad.setProgress(progress);
				labelGameState.setText("Load state: " + step.toString());

				if (step == eLoadSteps.FINISHED) {
					// this is a stupid / easy way to fix bug
					// without this load content loads the board before its
					// initialized
					try {
						TimeUnit.MILLISECONDS.sleep(400);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						// e.printStackTrace();
					}
					loadContent(gameManager.getCurrentGame());
				}
			}
		});
	}

	private void refreshBoard() {
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board.length; j++) {
				board[i][j].Refresh();
			}
		}
	}

	private enum eHumanSteps {
		WAIT_FOR_TURN, DICE, SELECT_TILES,
		// FLIP,
		CHOOSE_LETTERS, CHOOSE_WORD,;

		public eHumanSteps next() {
			if (ordinal() == values().length - 1)
				return values()[0];
			return values()[ordinal() + 1];
		}
	};

	public void TileClicked(TileController tile) {
		if (gameManager.getCurrentGame().getCurrentPlayer().getType() == ePlayerType.HUMAN) {
			if (currentStep == eHumanSteps.SELECT_TILES) {
				if (tile.getTile().getState() == eTileState.FACE_DOWN) {
					tile.getTile().setSelected(!tile.getTile().isSelected());
				}
			} else if (currentStep == eHumanSteps.CHOOSE_LETTERS) {
				if ((!tile.getTile().isSelected()) &&
						(tile.getTile().getState() == eTileState.FACE_UP)){
					tile.getTile().setSelected(true);
					currentWord.add(tile.getTile());
					updateWordLabel();
				}
			}
		}
	}

	private void updateWordLabel() {
		String curWord = "";

		for (Tile tile : currentWord) {
			curWord = curWord + tile.getSign();
		}

		labelWord.setText("Word: " + curWord);
	}
}
